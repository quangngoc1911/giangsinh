<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Christmas - Final Clean</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/introjs.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/intro.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000000;
        font-family: "Segoe UI", sans-serif;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
      }

      /* UI Center Vandiep */
      #ui-layer {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 100;
      }

      /* Guide text Vandiep */
      .guide {
        color: rgba(255, 255, 255, 0.6);
        font-size: 25px;
        margin-bottom: 20px;
        text-shadow: 0 2px 4px black;
      }

      button {
        pointer-events: auto;
        cursor: pointer;
        background: linear-gradient(to bottom, #d32f2f, #8b0000);
        color: #fff;
        border: 2px solid #ffd700;
        padding: 15px 50px;
        border-radius: 30px;
        font-weight: 800;
        font-size: 16px;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Camera Preview Vandiep */
      #camera-preview {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 160px;
        height: 120px;
        border: 2px solid rgba(255, 0, 0, 0.5);
        transform: scaleX(-1);
        opacity: 0.7;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
        object-fit: cover;
        z-index: 101;
      }

      /* Responsive camera preview cho tablet */
      @media (max-width: 768px) {
        #camera-preview {
          width: 120px;
          height: 90px;
          top: 10px;
          right: 10px;
        }
      }

      /* Responsive camera preview cho ƒëi·ªán tho·∫°i */
      @media (max-width: 480px) {
        #camera-preview {
          width: 90px;
          height: 68px;
          top: 35px;
          right: 8px;
          border: 1.5px solid rgba(255, 0, 0, 0.5);
          border-radius: 6px;
        }
      }

      /* Vandiep */
      #copyright {
        position: absolute;
        bottom: 10px;
        right: 15px;
        color: rgba(255, 255, 255, 0.3);
        font-size: 12px;
        z-index: 100;
        font-family: sans-serif;
        pointer-events: none;
        font-style: italic;
      }

      #error-log {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        color: red;
        background: rgba(0, 0, 0, 0.8);
        z-index: 999;
        padding: 10px;
      }

      /* Custom Intro.js styles */
      .introjs-overlay {
        background-color: rgba(0, 0, 0, 0.8) !important;
        z-index: 10001 !important;
        position: fixed !important;
      }

      .introjs-tooltip {
        background: linear-gradient(135deg, #1a1a2e, #16213e) !important;
        border: 2px solid #ffd700 !important;
        border-radius: 12px !important;
        box-shadow: 0 8px 32px rgba(255, 215, 0, 0.3) !important;
        color: white !important;
        padding: 20px !important;
        z-index: 10002 !important;
        position: fixed !important;
        pointer-events: auto !important;
      }

      .introjs-tooltip .introjs-tooltiptext {
        color: #e0e0e0 !important;
      }

      .introjs-tooltip .introjs-tooltip-title {
        color: #ffd700 !important;
        font-size: 18px !important;
        font-weight: 700 !important;
        margin-bottom: 8px !important;
      }

      .introjs-tooltipbuttons {
        display: flex !important;
        gap: 8px !important;
        justify-content: center !important;
        margin-top: 15px !important;
        flex-wrap: nowrap !important;
        align-items: center !important;
        flex-direction: row !important;
        width: 100% !important;
        border-top: none !important;
        padding-top: 0 !important;
        pointer-events: auto !important;
      }

      .introjs-button {
        background: linear-gradient(to bottom, #d32f2f, #8b0000) !important;
        color: #fff !important;
        border: 2px solid #ffd700 !important;
        border-radius: 6px !important;
        padding: 8px 16px !important;
        font-weight: 700 !important;
        font-size: 12px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        display: inline-flex !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
        white-space: nowrap !important;
        min-height: 36px !important;
        min-width: 80px !important;
        margin: 0 !important;
        box-shadow: 0 4px 12px rgba(211, 47, 47, 0.3) !important;
        text-decoration: none !important;
        flex-shrink: 0 !important;
        -webkit-font-smoothing: antialiased !important;
        -moz-osx-font-smoothing: grayscale !important;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
        letter-spacing: 0.5px !important;
        line-height: 1.2 !important;
        pointer-events: auto !important;
        -webkit-touch-callout: none !important;
        -webkit-user-select: none !important;
      }

      .introjs-button:hover {
        background: linear-gradient(to bottom, #ff3333, #aa0000) !important;
        transform: translateY(-2px) !important;
        box-shadow: 0 8px 24px rgba(255, 0, 0, 0.6) !important;
      }

      .introjs-button:active {
        transform: translateY(0) !important;
      }

      .introjs-button.introjs-skipbutton {
        background: linear-gradient(to bottom, #777, #555) !important;
        border-color: #999 !important;
        color: #fff !important;
      }

      .introjs-button.introjs-skipbutton:hover {
        background: linear-gradient(to bottom, #777, #555) !important;
        box-shadow: 
          0 0 0 0 rgba(255, 0, 0, 0.7),
          0 0 0 4px rgba(255, 0, 0, 0.5),
          0 0 0 8px rgba(255, 0, 0, 0.3),
          0 8px 24px rgba(100, 100, 100, 0.4) !important;
        animation: pulse-ring 0.6s ease-out infinite !important;
      }

      @keyframes pulse-ring {
        0% {
          box-shadow: 
            0 0 0 0 rgba(255, 0, 0, 0.9),
            0 0 0 4px rgba(255, 0, 0, 0.6),
            0 0 0 8px rgba(255, 0, 0, 0.3),
            0 8px 24px rgba(100, 100, 100, 0.4);
        }
        50% {
          box-shadow: 
            0 0 0 8px rgba(255, 0, 0, 0.4),
            0 0 0 12px rgba(255, 0, 0, 0.3),
            0 0 0 16px rgba(255, 0, 0, 0.1),
            0 8px 24px rgba(100, 100, 100, 0.4);
        }
        100% {
          box-shadow: 
            0 0 0 16px rgba(255, 0, 0, 0),
            0 0 0 20px rgba(255, 0, 0, 0),
            0 0 0 24px rgba(255, 0, 0, 0),
            0 8px 24px rgba(100, 100, 100, 0.4);
        }
      }

      .introjs-bullet {
        background: #666 !important;
        width: 10px !important;
        height: 10px !important;
        margin: 0 4px !important;
      }

      .introjs-bullet.active {
        background: #ffd700 !important;
      }

      /* ·∫®n ƒë∆∞·ªùng ngang v√† arrow c·ªßa intro.js */
      .introjs-arrow {
        display: none !important;
      }

      .introjs-tooltip::before,
      .introjs-tooltip::after {
        display: none !important;
      }

      .introjs-tooltip-top::before,
      .introjs-tooltip-bottom::after {
        display: none !important;
      }

      /* Highlight element - box shadow n·ªïi b·∫≠t */
      .active-tour {
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8) !important;
        outline: 3px solid #ffd700 !important;
        outline-offset: 0 !important;
      }

      .introjs-helperLayer {
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important,
                    0 0 40px rgba(255, 0, 0, 0.6) !important,
                    0 0 60px rgba(255, 0, 0, 0.4) !important,
                    inset 0 0 0 3px #ffd700 !important !important;
        z-index: 10001 !important;
        position: fixed !important;
      }

      /* Responsive cho ƒëi·ªán tho·∫°i */
      @media (max-width: 768px) {
        .introjs-tooltipbuttons {
          flex-direction: row !important;
          gap: 6px !important;
          justify-content: center !important;
        }

        .introjs-button {
          padding: 8px 14px !important;
          font-size: 12px !important;
          min-width: 75px !important;
          min-height: 34px !important;
          flex: 0 0 auto !important;
        }

        .introjs-tooltip {
          padding: 15px !important;
          border-radius: 10px !important;
        }

        .introjs-tooltip .introjs-tooltip-title {
          font-size: 16px !important;
          margin-bottom: 10px !important;
        }

        .introjs-tooltip .introjs-tooltiptext {
          font-size: 13px !important;
          line-height: 1.4 !important;
        }
      }

      @media (max-width: 480px) {
        .introjs-tooltipbuttons {
          flex-direction: row !important;
          gap: 2px !important;
          justify-content: center !important;
          width: 100% !important;
          flex-wrap: nowrap !important;
        }
        .guide {
          font-size: 10px !important;
        }
        .introjs-button {
          padding: 6px 10px !important;
          font-size: 10px !important;
          min-width: 65px !important;
          min-height: 30px !important;
          flex: 0 1 auto !important;
          font-weight: 800 !important;
          -webkit-font-smoothing: antialiased !important;
          -moz-osx-font-smoothing: grayscale !important;
          text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5) !important;
          letter-spacing: 0.2px !important;
        }

        .introjs-tooltip {
          position: fixed !important;
          left: 50% !important;
          top: 50% !important;
          transform: translate(-50%, -50%) !important;
          width: 90vw !important;
          max-width: 90vw !important;
          margin: 0 !important;
          padding: 12px !important;
          z-index: 9999 !important;
          border-radius: 8px !important;
        }

        .introjs-tooltip .introjs-tooltip-title {
          font-size: 14px !important;
          margin-bottom: 8px !important;
        }

        .introjs-tooltip .introjs-tooltiptext {
          font-size: 12px !important;
          line-height: 1.3 !important;
        }

        .introjs-bullets {
          padding: 8px 0 !important;
        }
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 0.3; transform: scale(0.8); }
        50% { opacity: 1; transform: scale(1); }
      }
    </style>
  </head>
  <body>
    <!-- Loading screen khi ch·ªù camera -->
    <div id="loading-screen" style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      gap: 20px;
    ">
      <div style="
        width: 60px;
        height: 60px;
        border: 4px solid rgba(255, 215, 0, 0.3);
        border-top-color: #ffd700;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      "></div>
      
      <h2 style="
        color: #ffd700;
        font-size: 24px;
        margin: 0;
        text-align: center;
      ">ƒêang m·ªü camera...</h2>
      
      <p style="
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
        margin: 0;
        text-align: center;
        max-width: 300px;
      ">Vui l√≤ng cho ph√©p truy c·∫≠p camera ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>

      <div style="
        margin-top: 20px;
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      ">
        <div style="
          width: 12px;
          height: 12px;
          background: #ffd700;
          border-radius: 50%;
          animation: pulse 1.5s ease-in-out infinite;
        "></div>
        <div style="
          width: 12px;
          height: 12px;
          background: #ffd700;
          border-radius: 50%;
          animation: pulse 1.5s ease-in-out 0.3s infinite;
        "></div>
        <div style="
          width: 12px;
          height: 12px;
          background: #ffd700;
          border-radius: 50%;
          animation: pulse 1.5s ease-in-out 0.6s infinite;
        "></div>
      </div>
    </div>

    <!-- UI Vandiep -->
    <div id="ui-layer">
      <!-- Vandiep -->
      <div class="guide">
        üñê <b>Open:</b> Explode (T·ª± ƒë·ªông xoay) &nbsp;|&nbsp; ü§è
        <b>Pinch:</b> Ch·ªçn h√¨nh &nbsp;|&nbsp; ‚úä <b>Fist:</b> Tree &nbsp;|&nbsp;
        üëç <b>Thumbs Up:</b> Tuy·∫øt r∆°i
      </div>
      <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <!-- Vandiep -->
    <div id="copyright">¬© by C√° con</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      // ==========================================
      // INTRO.JS TOUR SETUP
      // ==========================================
      let tour = null;

      function initTour() {
        tour = introJs();

        tour.setOptions({
          steps: [
            {
              intro: 'üëã <strong>Ch√†o m·ª´ng H√¢n ƒë·∫øn Magic Christmas!</strong><br><br>C√° s·∫Ω h∆∞·ªõng d·∫´n H√¢n s·ª≠ d·ª•ng ·ª©ng d·ª•ng n√†y. S·ª≠ d·ª•ng tr√™n laptop s·∫Ω cho hi·ªáu ·ª©ng m∆∞·ª£t v√† ƒë·∫πp h∆°n √° nhen.<br><br>D√πng c√°c c·ª≠ ch·ªâ tay ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi hi·ªáu ·ª©ng 3D tuy·ªát ƒë·∫πp.',
              position: 'center'
            },
            {
              element: '.guide',
              intro: 'üìñ <strong>H∆∞·ªõng d·∫´n c·ª≠ ch·ªâ tay:</strong><br><br>üñêÔ∏è <b>M·ªü tay:</b> m·ªü l√≤ng b√†n tay l√† hi·ªáu ·ª©ng n·ªï. L√∫c n√†y s·∫Ω c√≥ th·ªÉ ch·ªçn ·∫£nh.<br>ü§è <b>Ghim:</b> ch·ª•m t·ª´ t·ª´ 2 ƒë·∫ßu ng√≥n tay l·∫°i ƒë·ªÉ ch·ªçn ·∫£nh<br>‚úä <b>N·∫Øm tay:</b> s·∫Ω hi·ªÉn th·ªã c√¢y th√¥ng<br>üëç <b>Gi∆° ng√≥n c√°i:</b> l√† hi·ªáu ·ª©ng tuy·∫øt r∆°i',
              position: 'bottom'
            },
            {
              element: '#camera-preview',
              intro: 'üìπ <strong>Camera c·ªßa em b√©</strong><br><br>·ª®ng d·ª•ng s·∫Ω theo d√µi chuy·ªÉn ƒë·ªông tay c·ªßa H√¢n t·ª´ camera n√†y. H·∫•n nh·ªõ cho ph√©p truy c·∫≠p camera nghen!',
              position: 'left'
            },
            {
              element: '#btnStart',
              intro: 'üéØ <strong>N√∫t START MAGIC</strong><br><br>Nh·∫•n n√∫t n√†y ƒë·ªÉ b·∫Øt ƒë·∫ßu ·ª©ng d·ª•ng v√† s·ª≠ d·ª•ng c√°c c·ª≠ ch·ªâ tay ƒë·ªÉ ƒëi·ªÅu khi·ªÉn.',
              position: 'top'
            },
            {
              intro: '‚ú® <strong>Th√†nh c√¥ng!</strong><br><br>H√¢n ƒë√£ ho√†n th√†nh c√°c b∆∞·ªõc h∆∞·ªõng d·∫´n. Nhh·∫•n n√∫t <b>START MAGIC</b> ƒë·ªÉ b·∫Øt ƒë·∫ßu tr·∫£i nghi·ªám Magic Christmas.<br><br>Ch√∫c H√¢m xem vui v·∫ª n√†! üéÑ‚ù§Ô∏è',
              position: 'center'
            }
          ],
          tooltipPosition: 'bottom',
          highlightClass: 'active-tour',
          buttonClass: 'introjs-button',
          showBullets: true,
          scrollToElement: true,
          padding: 15,
          doneLabel: '‚ú® B·∫Øt ƒë·∫ßu!',
          nextLabel: '‚Üí Ti·∫øp theo',
          prevLabel: '‚Üê Quay l·∫°i',
          skipLabel: '‚äó',
          exitOnEsc: false,
          exitOnOverlayClick: false,
          disableInteraction: false,
        });

        tour.oncomplete(() => {
          console.log('Tour ho√†n th√†nh!');
        });

        tour.onexit(() => {
          console.log('Tour b·ªã h·ªßy');
        });
      }

      // Ch·∫°y tour khi trang load
      window.addEventListener('load', () => {
        setTimeout(() => {
          console.log('Kh·ªüi t·∫°o tour...');
          initTour();
          if (tour) {
            tour.start();
          }
        }, 300);
      });

      // ==========================================
      // 1. RESOURCES CONFIG Vandiep
      // ==========================================
      const MUSIC_URL = "./audio.mp3";
      let bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 1.0;

      const loader = new THREE.TextureLoader();
      const photoFiles = [
        "./image1.jpg",
        "./image2.jpg",
        "./image3.jpg",
        "./image4.jpg",
      ];
      const photoTextures = [];
      photoFiles.forEach((f, i) => (photoTextures[i] = loader.load(f)));

      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        const cx = 64,
          cy = 64;

        if (type === "gold_glow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.2, "#FFFFE0");
          grd.addColorStop(0.5, "#FFD700");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "red_light") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0, "#FFAAAA");
          grd.addColorStop(0.3, "#FF0000");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "gift_red") {
          ctx.fillStyle = "#D32F2F";
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
          ctx.strokeStyle = "rgba(0,0,0,0.3)";
          ctx.lineWidth = 2;
          ctx.strokeRect(20, 20, 88, 88);
        } else if (type === "snow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.5, "#E0E0E0");
          grd.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        }
        return new THREE.CanvasTexture(canvas);
      }

      const textures = {
        gold: createCustomTexture("gold_glow"),
        red: createCustomTexture("red_light"),
        gift: createCustomTexture("gift_red"),
        snow: createCustomTexture("snow"),
      };

      // ==========================================
      // 2. SYSTEM CONFIG Vandiep
      // ==========================================
      const getConfig = () => {
        const isMobile = window.innerWidth <= 480;
        return {
          goldCount: isMobile ? 1000 : 2000,        // Gi·∫£m 50% tr√™n mobile
          redCount: isMobile ? 150 : 300,           // Gi·∫£m 50% tr√™n mobile
          giftCount: isMobile ? 75 : 150,           // Gi·∫£m 50% tr√™n mobile
          explodeRadius: 65,
          photoOrbitRadius: 20,
          treeHeight: isMobile ? 40 : 70,
          treeBaseRadius: isMobile ? 20 : 35,
        };
      };
      const CONFIG = getConfig();

      let scene, camera, renderer;
      let groupGold, groupRed, groupGift;
      let photoMeshes = [];
      let titleMesh, starMesh, loveMesh;
      let snowGroup = null;
      let backgroundStars = null;
      let confettiGroup = null;

      let state = "TREE";
      let selectedIndex = 0;
      let handX = 0.5;
      let isSnowing = false;

      // ==========================================
      // 3. THREE.JS SYSTEM Vandiep
      // ==========================================
      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        const isMobileRenderer = window.innerWidth <= 480;
        renderer = new THREE.WebGLRenderer({ antialias: isMobileRenderer ? false : true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Gi·∫£m pixel ratio tr√™n mobile ƒë·ªÉ m∆∞·ª£t h∆°n
        renderer.setPixelRatio(isMobileRenderer ? 1 : Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        groupGold = createParticleSystem("gold", CONFIG.goldCount, 2.0);
        groupRed = createParticleSystem("red", CONFIG.redCount, 3.5);
        groupGift = createParticleSystem("gift", CONFIG.giftCount, 3.0);

        createSnowSystem();
        createBackgroundStars();
        createPhotos();
        createDecorations();
        animate();
      }

      function createBackgroundStars() {
        const isMobileStars = window.innerWidth <= 480;
        const starCount = isMobileStars ? 150 : 300;  // Gi·∫£m 50% tr√™n mobile
        const positions = [];
        const sizes = [];

        for (let i = 0; i < starCount; i++) {
          positions.push(
            (Math.random() - 0.5) * 500,
            (Math.random() - 0.5) * 500,
            -200 - Math.random() * 100
          );
          sizes.push(0.5 + Math.random() * 1.5);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

        const mat = new THREE.PointsMaterial({
          size: 2,
          color: 0xffffff,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });

        backgroundStars = new THREE.Points(geo, mat);
        scene.add(backgroundStars);
      }

      function createConfetti() {
        if (confettiGroup) {
          scene.remove(confettiGroup);
          confettiGroup.geometry.dispose();
          confettiGroup.material.dispose();
        }

        const isMobileConfetti = window.innerWidth <= 480;
        const confettiCount = isMobileConfetti ? 50 : 100;  // Gi·∫£m 50% tr√™n mobile
        const positions = [];
        const velocities = [];
        const colors = [];
        const sizes = [];

        const colorPalette = [0xffd700, 0xff6b6b, 0x4ecdc4, 0xffd93d, 0x6bcf7f];

        for (let i = 0; i < confettiCount; i++) {
          positions.push(0, 0, 0);
          velocities.push(
            (Math.random() - 0.5) * 2,
            Math.random() * 2 + 1,
            (Math.random() - 0.5) * 2
          );
          const color = new THREE.Color(
            colorPalette[Math.floor(Math.random() * colorPalette.length)]
          );
          colors.push(color.r, color.g, color.b);
          sizes.push(1 + Math.random() * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
        geo.userData = { velocities: velocities, life: 0 };

        const mat = new THREE.PointsMaterial({
          size: 3,
          vertexColors: true,
          transparent: true,
          opacity: 1.0,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });

        confettiGroup = new THREE.Points(geo, mat);
        scene.add(confettiGroup);
      }

      function createSnowSystem() {
        const isMobileSnow = window.innerWidth <= 480;
        const snowCount = isMobileSnow ? 300 : 800;  // Gi·∫£m 62% tr√™n mobile
        const positions = [];
        const velocities = [];
        const sizes = [];
        const rotations = [];
        const opacities = [];

        for (let i = 0; i < snowCount; i++) {
          positions.push(
            (Math.random() - 0.5) * 250,
            Math.random() * 250 + 50,
            (Math.random() - 0.5) * 250
          );
          velocities.push(
            (Math.random() - 0.5) * 0.8,
            -Math.random() * 0.6 - 0.4,
            (Math.random() - 0.5) * 0.8
          );
          sizes.push(2 + Math.random() * 3);
          rotations.push(Math.random() * Math.PI * 2);
          opacities.push(0.6 + Math.random() * 0.4);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
        geo.userData = {
          velocities: velocities,
          originalPositions: [...positions],
          rotations: rotations,
          opacities: opacities,
        };

        const mat = new THREE.PointsMaterial({
          size: 4,
          map: textures.snow,
          transparent: true,
          opacity: 1.0,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
          vertexColors: false,
        });

        snowGroup = new THREE.Points(geo, mat);
        snowGroup.visible = false;
        scene.add(snowGroup);
      }

      function createParticleSystem(type, count, size) {
        const pPositions = [];
        const pExplodeTargets = [];
        const pTreeTargets = [];
        const pHeartTargets = [];
        const sizes = [];
        const phases = [];

        for (let i = 0; i < count; i++) {
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          let radiusRatio =
            type === "gold"
              ? Math.sqrt(Math.random())
              : 0.9 + Math.random() * 0.1;
          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
          const r = maxR * radiusRatio;
          const theta = Math.random() * Math.PI * 2;
          pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          const u = Math.random();
          const v = Math.random();
          const phi = Math.acos(2 * v - 1);
          const lam = 2 * Math.PI * u;
          let radMult = type === "gift" ? 1.2 : 1.0;
          const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
          pExplodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );

          const tHeart = Math.random() * Math.PI * 2;
          let hx = 16 * Math.pow(Math.sin(tHeart), 3);
          let hy =
            13 * Math.cos(tHeart) -
            5 * Math.cos(2 * tHeart) -
            2 * Math.cos(3 * tHeart) -
            Math.cos(4 * tHeart);

          const rFill = Math.pow(Math.random(), 0.3);
          hx *= rFill;
          hy *= rFill;
          let hz = (Math.random() - 0.5) * 8 * rFill;

          const noise = 1.0;
          hx += (Math.random() - 0.5) * noise;
          hy += (Math.random() - 0.5) * noise;
          hz += (Math.random() - 0.5) * noise;

          const scaleH = 2.2;
          pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz);

          pPositions.push(
            pTreeTargets[i * 3],
            pTreeTargets[i * 3 + 1],
            pTreeTargets[i * 3 + 2]
          );
          sizes.push(size);
          phases.push(Math.random() * Math.PI * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(pPositions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

        const colors = new Float32Array(count * 3);
        const baseColor = new THREE.Color();
        if (type === "gold") baseColor.setHex(0xffd700);
        else if (type === "red") baseColor.setHex(0xff0000);
        else baseColor.setHex(0xffffff);

        for (let i = 0; i < count; i++) {
          colors[i * 3] = baseColor.r;
          colors[i * 3 + 1] = baseColor.g;
          colors[i * 3 + 2] = baseColor.b;
        }
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        geo.userData = {
          tree: pTreeTargets,
          explode: pExplodeTargets,
          heart: pHeartTargets,
          phases: phases,
          baseColor: baseColor,
          baseSize: size,
        };

        const mat = new THREE.PointsMaterial({
          size: size,
          map: textures[type],
          transparent: true,
          opacity: 1.0,
          vertexColors: true,
          blending:
            type === "gift" ? THREE.NormalBlending : THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        const borderGeo = new THREE.PlaneGeometry(9, 9);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });

        for (let i = 0; i < 4; i++) {
          const mat = new THREE.MeshBasicMaterial({
            map: photoTextures[i],
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geo, mat);
          const border = new THREE.Mesh(borderGeo, borderMat);
          border.position.z = -0.1;
          mesh.add(border);
          mesh.visible = false;
          mesh.scale.set(0, 0, 0);
          scene.add(mesh);
          photoMeshes.push(mesh);
        }
      }

      function createDecorations() {
        const canvas = document.createElement("canvas");
        canvas.width = 2048;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        const gradient = ctx.createLinearGradient(0, 0, 2048, 0);
        gradient.addColorStop(0, "#FFD700");
        gradient.addColorStop(0.3, "#FF6B6B");
        gradient.addColorStop(0.6, "#4ECDC4");
        gradient.addColorStop(1, "#FFD700");

        ctx.font = 'bold italic 140px "Times New Roman", serif';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 50;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 8;
        ctx.strokeText("MERRY CHRISTMAS", 1024, 256);

        ctx.fillStyle = gradient;
        ctx.fillText("MERRY CHRISTMAS", 1024, 256);

        ctx.shadowBlur = 80;
        ctx.shadowColor = "#FFD700";
        ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
        ctx.fillText("MERRY CHRISTMAS", 1024, 256);

        const tex = new THREE.CanvasTexture(canvas);
        tex.needsUpdate = true;
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
        });
        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
        
        // Responsive title position - ƒë·∫©y xu·ªëng tr√™n ƒëi·ªán tho·∫°i nh∆∞ng kh√¥ng che c√¢y
        const isMobileInit = window.innerWidth <= 480;
        titleMesh.position.set(0, isMobileInit ? 35 : 50, 0);
        scene.add(titleMesh);

        const starCanvas = document.createElement("canvas");
        starCanvas.width = 128;
        starCanvas.height = 128;
        const sCtx = starCanvas.getContext("2d");
        sCtx.fillStyle = "#FFFF00";
        sCtx.shadowColor = "#FFF";
        sCtx.shadowBlur = 20;
        sCtx.beginPath();
        const cx = 64,
          cy = 64,
          outer = 50,
          inner = 20;
        for (let i = 0; i < 5; i++) {
          sCtx.lineTo(
            cx + Math.cos(((18 + i * 72) / 180) * Math.PI) * outer,
            cy - Math.sin(((18 + i * 72) / 180) * Math.PI) * outer
          );
          sCtx.lineTo(
            cx + Math.cos(((54 + i * 72) / 180) * Math.PI) * inner,
            cy - Math.sin(((54 + i * 72) / 180) * Math.PI) * inner
          );
        }
        sCtx.closePath();
        sCtx.fill();
        const starTex = new THREE.CanvasTexture(starCanvas);
        const starMat = new THREE.MeshBasicMaterial({
          map: starTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        
        // Responsive star size - nh·ªè h∆°n tr√™n ƒëi·ªán tho·∫°i
        const isMobileStar = window.innerWidth <= 480;
        const starSize = isMobileStar ? 6 : 12;  // Nh·ªè 50% tr√™n mobile
        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(starSize, starSize), starMat);
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
        scene.add(starMesh);

        loveMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(1, 1),
          new THREE.MeshBasicMaterial({ visible: false })
        );
        loveMesh.visible = false;
        scene.add(loveMesh);
      }

      function updateParticleGroup(
        group,
        type,
        targetState,
        speed,
        handRotY,
        time
      ) {
        const positions = group.geometry.attributes.position.array;
        const sizes = group.geometry.attributes.size.array;
        const colors = group.geometry.attributes.color.array;
        const phases = group.geometry.userData.phases;
        const baseColor = group.geometry.userData.baseColor;
        const baseSize = group.geometry.userData.baseSize;

        const targetKey =
          targetState === "TREE"
            ? "tree"
            : targetState === "HEART"
            ? "heart"
            : "explode";
        const targets =
          group.geometry.userData[
            targetState === "PHOTO" ? "explode" : targetKey
          ];

        for (let i = 0; i < positions.length; i++) {
          positions[i] += (targets[i] - positions[i]) * speed;
        }
        group.geometry.attributes.position.needsUpdate = true;

        const count = positions.length / 3;

        if (targetState === "TREE") {
          group.rotation.y += 0.003;

          // Tr√™n mobile, ch·ªâ update color m·ªói 2 frames ƒë·ªÉ t·ªëi ∆∞u
          const isMobileUpdate = window.innerWidth <= 480;
          const shouldUpdateColor = !isMobileUpdate || (Math.floor(time * 30) % 2 === 0);
          
          if (shouldUpdateColor) {
            for (let i = 0; i < count; i++) {
              sizes[i] = baseSize;
              let brightness = 1.0;
              if (type === "red") {
                brightness = 0.5 + 0.5 * Math.sin(time * 3 + phases[i]);
              } else if (type === "gold") {
                brightness = 0.8 + 0.4 * Math.sin(time * 10 + phases[i]);
              }
              colors[i * 3] = baseColor.r * brightness;
              colors[i * 3 + 1] = baseColor.g * brightness;
              colors[i * 3 + 2] = baseColor.b * brightness;
            }
            group.geometry.attributes.color.needsUpdate = true;
            group.geometry.attributes.size.needsUpdate = true;
          }
        } else if (targetState === "HEART") {
          group.rotation.y = 0;
          const beatScale = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
          group.scale.set(beatScale, beatScale, beatScale);

          for (let i = 0; i < count; i++) {
            colors[i * 3] = baseColor.r;
            colors[i * 3 + 1] = baseColor.g;
            colors[i * 3 + 2] = baseColor.b;
            if (i % 3 === 0) sizes[i] = baseSize;
            else sizes[i] = 0;
          }
          group.geometry.attributes.color.needsUpdate = true;
          group.geometry.attributes.size.needsUpdate = true;
        } else {
          group.scale.set(1, 1, 1);
          group.rotation.y += (handRotY - group.rotation.y) * 0.1;

          for (let i = 0; i < count; i++) {
            sizes[i] = baseSize;
            let brightness = 1.0;
            if (type === "gold" || type === "red") {
              brightness = 0.8 + 0.5 * Math.sin(time * 12 + phases[i]);
            }
            colors[i * 3] = baseColor.r * brightness;
            colors[i * 3 + 1] = baseColor.g * brightness;
            colors[i * 3 + 2] = baseColor.b * brightness;
          }
          group.geometry.attributes.size.needsUpdate = true;
          group.geometry.attributes.color.needsUpdate = true;
        }
      }

      function updateSnow(snowGroup, time) {
        const positions = snowGroup.geometry.attributes.position.array;
        const velocities = snowGroup.geometry.userData.velocities;
        const originalPositions = snowGroup.geometry.userData.originalPositions;
        const rotations = snowGroup.geometry.userData.rotations;

        snowGroup.rotation.y += 0.001;

        for (let i = 0; i < positions.length; i += 3) {
          const idx = i / 3;
          const windEffect = Math.sin(time * 0.5 + idx * 0.1) * 0.1;
          positions[i] += velocities[idx * 3] + windEffect;
          positions[i + 1] += velocities[idx * 3 + 1];
          positions[i + 2] += velocities[idx * 3 + 2] + windEffect * 0.5;

          rotations[idx] += 0.02;

          if (positions[i + 1] < -60) {
            positions[i] = (Math.random() - 0.5) * 250;
            positions[i + 1] = Math.random() * 50 + 200;
            positions[i + 2] = (Math.random() - 0.5) * 250;
          }
        }
        snowGroup.geometry.attributes.position.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const isMobileAnim = window.innerWidth <= 480;
        const speed = isMobileAnim ? 0.12 : 0.08;  // TƒÉng speed ƒë·ªÉ animation m∆∞·ª£t h∆°n
        const handRotY = (handX - 0.5) * 4.0;

        updateParticleGroup(groupGold, "gold", state, speed, handRotY, time);
        updateParticleGroup(groupRed, "red", state, speed, handRotY, time);
        updateParticleGroup(groupGift, "gift", state, speed, handRotY, time);

        if (snowGroup && isSnowing) {
          updateSnow(snowGroup, time);
        }

        // Gi·∫£m update background stars tr√™n mobile - ch·ªâ update m·ªói 2 frames
        if (backgroundStars && (Math.floor(time * 30) % 2 === 0 || !isMobileAnim)) {
          backgroundStars.rotation.y += 0.0005;
          const sizes = backgroundStars.geometry.attributes.size.array;
          for (let i = 0; i < sizes.length; i++) {
            sizes[i] = 0.5 + Math.abs(Math.sin(time * 2 + i * 0.1)) * 1.5;
          }
          backgroundStars.geometry.attributes.size.needsUpdate = true;
        }

        if (titleMesh && titleMesh.visible) {
          titleMesh.rotation.y = Math.sin(time * 0.5) * 0.05;
          titleMesh.material.opacity = 0.8 + Math.sin(time * 3) * 0.2;
          titleMesh.scale.setScalar(1 + Math.sin(time * 2) * 0.05);
        }

        if (confettiGroup) {
          const positions = confettiGroup.geometry.attributes.position.array;
          const velocities = confettiGroup.geometry.userData.velocities;
          confettiGroup.geometry.userData.life += 0.016;

          let allDead = true;
          for (let i = 0; i < positions.length; i += 3) {
            const idx = i / 3;
            positions[i] += velocities[idx * 3];
            positions[i + 1] += velocities[idx * 3 + 1];
            positions[i + 2] += velocities[idx * 3 + 2];

            velocities[idx * 3 + 1] -= 0.05;

            if (positions[i + 1] > -100) allDead = false;
          }

          confettiGroup.geometry.attributes.position.needsUpdate = true;

          confettiGroup.material.opacity = Math.max(
            0,
            1 - confettiGroup.geometry.userData.life * 2
          );

          if (confettiGroup.geometry.userData.life > 2 || allDead) {
            scene.remove(confettiGroup);
            confettiGroup.geometry.dispose();
            confettiGroup.material.dispose();
            confettiGroup = null;
          }
        }

        photoMeshes.forEach((mesh, i) => {
          if (!mesh.material.map && photoTextures[i]) {
            mesh.material.map = photoTextures[i];
            mesh.material.needsUpdate = true;
          }
        });

        if (state === "TREE") {
          titleMesh.visible = true;
          starMesh.visible = true;
          loveMesh.visible = false;
          titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
          starMesh.rotation.z -= 0.02;
          starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);
          photoMeshes.forEach((m) => {
            m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            m.visible = false;
          });
        } else if (state === "HEART") {
          titleMesh.visible = false;
          starMesh.visible = false;
          loveMesh.visible = false;
          photoMeshes.forEach((m) => {
            m.visible = false;
          });
        } else if (state === "EXPLODE") {
          titleMesh.visible = false;
          starMesh.visible = false;
          loveMesh.visible = false;

          const rotationSpeed = 0.3;
          groupGold.rotation.y = time * rotationSpeed;

          const baseAngle = groupGold.rotation.y;
          const angleStep = (Math.PI * 2) / 4;
          let bestIdx = 0;
          let maxZ = -999;
          photoMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = baseAngle + i * angleStep;
            const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
            const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
            const y = Math.sin(time + i) * 3;
            mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            mesh.lookAt(camera.position);
            if (z > maxZ) {
              maxZ = z;
              bestIdx = i;
            }
            if (z > 5) {
              const ds = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
              mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
            } else {
              mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
            }
          });
          selectedIndex = bestIdx;
        } else if (state === "PHOTO") {
          loveMesh.visible = false;
          const isMobile = window.innerWidth <= 480;
          const photoScale = isMobile ? 3 : 5;  // Nh·ªè h∆°n tr√™n ƒëi·ªán tho·∫°i
          
          photoMeshes.forEach((mesh, i) => {
            if (i === selectedIndex) {
              mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
              mesh.scale.lerp(new THREE.Vector3(photoScale, photoScale, photoScale), 0.1);
              mesh.lookAt(camera.position);
              mesh.rotation.z = 0;
            } else {
              mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
          });
        }
        renderer.render(scene, camera);
      }

      function startSystem() {
        // K·∫øt th√∫c tour n·∫øu c√≤n ch·∫°y
        if (tour) {
          tour.exit();
        }

        document.getElementById("btnStart").style.display = "none";
        
        // Hi·ªÉn th·ªã loading screen
        const loadingScreen = document.getElementById('loading-screen');
        loadingScreen.style.display = 'flex';
        loadingScreen.style.opacity = '1';
        
        bgMusic.play().catch((e) => console.log(e));
        init3D();

        const video = document.getElementsByClassName("input_video")[0];
        const canvas = document.getElementById("camera-preview");
        canvas.width = 160;
        canvas.height = 120;
        const ctx = canvas.getContext("2d");
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        let cameraReady = false;
        let cameraTimeout = null;
        let hasRequestedPermission = false;

        // H√†m ·∫©n loading screen
        const hideLoadingScreen = () => {
          if (cameraTimeout) clearTimeout(cameraTimeout);
          loadingScreen.style.opacity = '0';
          loadingScreen.style.transition = 'opacity 0.5s ease-out';
          setTimeout(() => {
            loadingScreen.style.display = 'none';
          }, 500);
        };

        // H√†m hi·ªÉn th·ªã c·∫£nh b√°o timeout
        const showCameraTimeoutWarning = () => {
          const warningDiv = document.createElement('div');
          warningDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 30px;
            color: white;
            z-index: 11000;
            max-width: 90vw;
            text-align: center;
            box-shadow: 0 8px 32px rgba(255, 215, 0, 0.3);
          `;
          warningDiv.innerHTML = `
            <h2 style="color: #ffd700; margin-top: 0; font-size: 20px;">‚ö†Ô∏è Camera Kh√¥ng M·ªü</h2>
            <p style="margin: 15px 0; font-size: 14px; color: #e0e0e0;">
              Camera kh√¥ng ƒë∆∞·ª£c cho ph√©p ho·∫∑c kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã.
            </p>
            <p style="margin: 15px 0; font-size: 13px; color: #b0b0b0;">
              Vui l√≤ng ki·ªÉm tra:
            </p>
            <ul style="text-align: left; display: inline-block; color: #e0e0e0; font-size: 13px;">
              <li>‚úì Cho ph√©p truy c·∫≠p camera</li>
              <li>‚úì Ki·ªÉm tra camera c√≥ ƒë∆∞·ª£c k·∫øt n·ªëi</li>
              <li>‚úì Th·ª≠ t·∫£i l·∫°i trang</li>
            </ul>
            <button onclick="location.reload()" style="
              margin-top: 20px;
              background: linear-gradient(to bottom, #d32f2f, #8b0000);
              color: #fff;
              border: 2px solid #ffd700;
              padding: 10px 30px;
              border-radius: 6px;
              font-weight: 700;
              cursor: pointer;
              font-size: 14px;
            ">T·∫£i l·∫°i trang</button>
          `;
          document.body.appendChild(warningDiv);
          
          // ·∫®n loading screen
          loadingScreen.style.display = 'none';
        };

        // Timeout 10 gi√¢y - n·∫øu ch∆∞a nh·∫≠n ƒë∆∞·ª£c frame th√¨ hi·ªÉn th·ªã c·∫£nh b√°o
        cameraTimeout = setTimeout(() => {
          if (!cameraReady && hasRequestedPermission) {
            showCameraTimeoutWarning();
          }
        }, 10000);

        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        hands.onResults((results) => {
          // L·∫ßn ƒë·∫ßu ti√™n nh·∫≠n ƒë∆∞·ª£c frame t·ª´ camera = camera ƒë√£ m·ªü
          if (!cameraReady) {
            cameraReady = true;
            hideLoadingScreen();
          }

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            handX = lm[9].x;

            const thumbTip = lm[4];
            const thumbIP = lm[3];
            const thumbMCP = lm[2];
            const indexMCP = lm[5];

            const thumbUp = thumbTip.y < thumbIP.y && thumbTip.y < thumbMCP.y;
            const thumbAbove = thumbTip.y < indexMCP.y;

            if (thumbUp && thumbAbove) {
              if (!isSnowing && snowGroup) {
                isSnowing = true;
                snowGroup.visible = true;
              }
            } else {
              if (isSnowing && snowGroup) {
                isSnowing = false;
                snowGroup.visible = false;
              }
            }

            const tips = [8, 12, 16, 20];
            const wrist = lm[0];
            let openDist = 0;
            tips.forEach(
              (i) =>
                (openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y))
            );
            const avgDist = openDist / 4;
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

            if (avgDist < 0.25) {
              state = "TREE";
            } else if (pinchDist < 0.05) {
              state = "PHOTO";
            } else {
              state = "EXPLODE";
            }
          } else {
            state = "TREE";
          }
        });

        const cameraUtils = new Camera(video, {
          onFrame: async () => {
            hasRequestedPermission = true;  // Ng∆∞·ªùi d√πng ƒë√£ nh·∫•n cho ph√©p
            await hands.send({ image: video });
          },
          width: 640,
          height: 480,
        });
        cameraUtils.start();
      }

      window.addEventListener("resize", () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>